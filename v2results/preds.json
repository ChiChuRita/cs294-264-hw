{
  "django__django-10973": {
    "model_name_or_path": "gpt-5-mini",
    "instance_id": "django__django-10973",
    "model_patch": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 7fca6eff30..77148d20fe 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -38,27 +38,41 @@ class DatabaseClient(BaseDatabaseClient):\n         sigint_handler = signal.getsignal(signal.SIGINT)\n         try:\n             if passwd:\n-                # Create temporary .pgpass file.\n-                temp_pgpass = NamedTemporaryFile(mode='w+')\n+                # Prefer setting PGPASSWORD in the environment for subprocess.run,\n+                # which is supported on Python 3.5+ (Django 2.1+ minimum).\n+                # Fall back to creating a temporary .pgpass file if writing\n+                # the password is not possible due to encoding issues.\n+                env = os.environ.copy()\n+                env['PGPASSWORD'] = passwd\n+                # Allow SIGINT to pass to psql to abort queries.\n+                signal.signal(signal.SIGINT, signal.SIG_IGN)\n                 try:\n-                    print(\n-                        _escape_pgpass(host) or '*',\n-                        str(port) or '*',\n-                        _escape_pgpass(dbname) or '*',\n-                        _escape_pgpass(user) or '*',\n-                        _escape_pgpass(passwd),\n-                        file=temp_pgpass,\n-                        sep=':',\n-                        flush=True,\n-                    )\n-                    os.environ['PGPASSFILE'] = temp_pgpass.name\n+                    subprocess.run(args, env=env, check=True)\n                 except UnicodeEncodeError:\n-                    # If the current locale can't encode the data, let the\n-                    # user input the password manually.\n-                    pass\n-            # Allow SIGINT to pass to psql to abort queries.\n-            signal.signal(signal.SIGINT, signal.SIG_IGN)\n-            subprocess.check_call(args)\n+                    # If the current locale can't encode the data, fall back to\n+                    # using a temporary .pgpass file so the user can input the\n+                    # password manually if needed.\n+                    temp_pgpass = NamedTemporaryFile(mode='w+')\n+                    try:\n+                        print(\n+                            _escape_pgpass(host) or '*',\n+                            str(port) or '*',\n+                            _escape_pgpass(dbname) or '*',\n+                            _escape_pgpass(user) or '*',\n+                            _escape_pgpass(passwd),\n+                            file=temp_pgpass,\n+                            sep=':',\n+                            flush=True,\n+                        )\n+                        os.environ['PGPASSFILE'] = temp_pgpass.name\n+                        subprocess.check_call(args)\n+                    except UnicodeEncodeError:\n+                        # If even writing to the temp file fails, let psql prompt.\n+                        pass\n+            else:\n+                # No password provided \u2014 use the original behavior.\n+                signal.signal(signal.SIGINT, signal.SIG_IGN)\n+                subprocess.check_call(args)\n         finally:\n             # Restore the original SIGINT handler.\n             signal.signal(signal.SIGINT, sigint_handler)\n"
  },
  "django__django-13297": {
    "model_name_or_path": "gpt-5-mini",
    "instance_id": "django__django-13297",
    "model_patch": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex ea5baca08d..f1076a4bef 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -27,6 +27,25 @@ class ContextMixin:\n         kwargs.setdefault('view', self)\n         if self.extra_context is not None:\n             kwargs.update(self.extra_context)\n+        # Evaluate any SimpleLazyObject values so that the context contains real\n+        # values. This avoids exposing SimpleLazyObject instances in the context\n+        # (e.g. URL kwargs), which can cause errors when consumers expect plain\n+        # values (like using them in queries).\n+        for key, value in list(kwargs.items()):\n+            if isinstance(value, SimpleLazyObject):\n+                try:\n+                    # Force evaluation of the lazy object. _setup() will initialize\n+                    # the wrapped object if it hasn't been already.\n+                    value._setup()\n+                except Exception:\n+                    # If forcing evaluation fails for some reason, leave the\n+                    # lazy object as-is to avoid raising unexpected errors here.\n+                    continue\n+                try:\n+                    kwargs[key] = value._wrapped\n+                except Exception:\n+                    # On any unexpected error, don't replace the value.\n+                    kwargs[key] = value\n         return kwargs\n \n \n"
  },
  "astropy__astropy-7166": {
    "model_name_or_path": "gpt-5-mini",
    "instance_id": "astropy__astropy-7166",
    "model_patch": "diff --git a/astropy/utils/misc.py b/astropy/utils/misc.py\nindex de3fb01d1..bf59ddde2 100644\n--- a/astropy/utils/misc.py\n+++ b/astropy/utils/misc.py\n@@ -528,14 +528,55 @@ class InheritDocstrings(type):\n                 not key.startswith('_'))\n \n         for key, val in dct.items():\n-            if (inspect.isfunction(val) and\n-                is_public_member(key) and\n-                val.__doc__ is None):\n-                for base in cls.__mro__[1:]:\n-                    super_method = getattr(base, key, None)\n-                    if super_method is not None:\n-                        val.__doc__ = super_method.__doc__\n-                        break\n+            if not is_public_member(key):\n+                continue\n+\n+            # Determine if this member is a plain function or a descriptor\n+            # wrapping a function (property, classmethod, staticmethod).\n+            func = None\n+            wrapper_doc = getattr(val, '__doc__', None)\n+            if inspect.isfunction(val):\n+                func = val\n+            elif isinstance(val, classmethod) or isinstance(val, staticmethod):\n+                func = getattr(val, '__func__', None)\n+            elif isinstance(val, property):\n+                func = getattr(val, 'fget', None)\n+\n+            # If either the wrapper or the underlying function already has a\n+            # docstring, don't overwrite it.\n+            if (wrapper_doc is not None) or (func is not None and getattr(func, '__doc__', None) is not None):\n+                continue\n+\n+            for base in cls.__mro__[1:]:\n+                super_method = getattr(base, key, None)\n+                if super_method is None:\n+                    continue\n+\n+                # Get docstring from the superclass method, handling descriptors.\n+                super_doc = getattr(super_method, '__doc__', None)\n+                if isinstance(super_method, classmethod) or isinstance(super_method, staticmethod):\n+                    super_doc = getattr(getattr(super_method, '__func__', None), '__doc__', super_doc)\n+                elif isinstance(super_method, property):\n+                    super_doc = getattr(getattr(super_method, 'fget', None), '__doc__', super_doc)\n+\n+                if super_doc:\n+                    if func is not None:\n+                        try:\n+                            func.__doc__ = super_doc\n+                        except Exception:\n+                            # Be conservative: if we can't set it, try setting on\n+                            # the wrapper itself.\n+                            try:\n+                                val.__doc__ = super_doc\n+                            except Exception:\n+                                pass\n+                    else:\n+                        # Fallback: set on wrapper if possible\n+                        try:\n+                            val.__doc__ = super_doc\n+                        except Exception:\n+                            pass\n+                    break\n \n         super().__init__(name, bases, dct)\n \n"
  },
  "sphinx-doc__sphinx-9230": {
    "model_name_or_path": "gpt-5-mini",
    "instance_id": "sphinx-doc__sphinx-9230",
    "model_patch": "Agent reached maximum steps (100) without completing the task.\n\nNo changes detected to generate a patch."
  },
  "psf__requests-1921": {
    "model_name_or_path": "gpt-5-mini",
    "instance_id": "psf__requests-1921",
    "model_patch": "diff --git a/requests/models.py b/requests/models.py\nindex cd232e6..e72f826 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -391,7 +391,11 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         \"\"\"Prepares the given HTTP headers.\"\"\"\n \n         if headers:\n-            self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())\n+            # Filter out headers explicitly set to None so they are not sent.\n+            self.headers = CaseInsensitiveDict(\n+                (to_native_string(name), value)\n+                for name, value in headers.items() if value is not None\n+            )\n         else:\n             self.headers = CaseInsensitiveDict()\n \n"
  }
}